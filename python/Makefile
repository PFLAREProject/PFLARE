# ~~~~~~~~~~~~~~~~~
# PFLARE - Steven Dargaville
# Makefile for python interface
# Copied from $PETSC_DIR/share/petsc/Makefile.basic.user
# This uses the compilers and flags defined in the PETSc configuration
# ~~~~~~~~~~~~~~~~~

# Can be overridden from the command line if needed
PYTHON ?= python3
CFLAGS   =
FFLAGS   =
CPPFLAGS =
FPPFLAGS =

# Read in the petsc compile/linking variables and makefile rules
include ${PETSC_DIR}/lib/petsc/conf/variables
include ${PETSC_DIR}/lib/petsc/conf/rules

# Make sure the setup.py can see the petsc compilers
export CC
export CXX
export FC

# Required during compilation to tell Cython where to look for libpflare
export LIBRARY_PATH := $(if $(LIBRARY_PATH),$(LIBRARY_PATH):)$(LIBDIR)
ifeq ($(shell uname -s 2>/dev/null),Darwin)
# macOS
export DYLD_FALLBACK_LIBRARY_PATH := $(if $(DYLD_FALLBACK_LIBRARY_PATH),$(DYLD_FALLBACK_LIBRARY_PATH):)$(PETSC_DIR)/$(PETSC_ARCH)/lib:$(LIBDIR)
else
# Required to run the python tests, telling it the location of libpetsc, blas, lapack and libpflare
export LD_LIBRARY_PATH := $(if $(LD_LIBRARY_PATH),$(LD_LIBRARY_PATH):)$(PETSC_DIR)/$(PETSC_ARCH)/lib:$(LIBDIR)
endif
# Required to locate petsc4py and our pflare python module
export PYTHONPATH := $(if $(PYTHONPATH),$(PYTHONPATH):)$(PETSC_DIR)/$(PETSC_ARCH)/lib:$(CURDIR)

# Build the Cython interface
# 1. Check if a compatible Cython is available - we need this for the petsc ci, as the default installed is 0.29
#    and yet petsc when installing petsc4py installs it's own cython >=3 which we don't have access to, but we have to match the version
# 2. If not, install it to the user's local site-packages (no sudo needed).
# 3. Call setup.py directly, which will now find the correct Cython and petsc4py.
python:
	@# This shell block ensures that if the Cython check fails, the Cython install runs, and then the build runs.
	@if ! $(PYTHON) -c "import sys; import Cython; v=tuple(map(int, Cython.__version__.split('.'))); sys.exit(0 if v >= (3,0) else 1)" 2>/dev/null; then \
		echo "Compatible Cython not found. Installing Cython>=3.0 to user directory..."; \
		$(PYTHON) -m pip install --user "cython>=3.0"; \
	fi
	$(PYTHON) setup.py build_ext --inplace

run_tests:
	 @if $(PYTHON) -c "import pflare" >/dev/null 2>&1; then \
		echo ""; \
		echo "Test AIRG with GMRES polynomials for 2D finite difference stencil with Python"; \
		$(PYTHON) ex2.py; \
		echo "Test AIRG with GMRES polynomials for 2D finite difference stencil with Python in parallel"; \
		$(MPIEXEC) -n 2 $(PYTHON) ex2.py; \
		echo ""; \
		echo "Test lAIR with GMRES polynomials for 2D finite difference stencil with Python"; \
		$(PYTHON) ex2.py -pc_air_z_type lair; \
		echo "Test lAIR with GMRES polynomials for 2D finite difference stencil with Python in parallel"; \
		$(MPIEXEC) -n 2 $(PYTHON) ex2.py -pc_air_z_type lair; \
		echo ""; \
		echo "Test single level GMRES polynomial preconditioning with Python"; \
		$(PYTHON) ex2.py -pc_type pflareinv -pc_pflareinv_type power; \
		echo "Test single level GMRES polynomial preconditioning with Python in parallel"; \
		$(MPIEXEC) -n 2 $(PYTHON) ex2.py -pc_type pflareinv -pc_pflareinv_type power; \
		echo ""; \
		echo "Test PMISR DDC CF splitting with Python"; \
		$(PYTHON) ex2_cf_splitting.py; \
		echo "Test PMISR DDC CF splitting with Python in parallel"; \
		$(MPIEXEC) -n 2 $(PYTHON) ex2_cf_splitting.py; \
	 else \
		echo 'Python tests skipped (PFLARE Python module not built or not found)'; \
	 fi

# ~~~~~~~~~~~
# ~~~~~~~~~~~
run_check:
	 @if $(PYTHON) -c "import pflare" >/dev/null 2>&1; then \
		echo "Python check"; \
		$(PYTHON) ex2.py -ksp_max_it 5 -on_error_abort && echo "OK" || (echo "FAIL" && exit 1); \
		echo "Parallel Python check"; \
		$(MPIEXEC) -n 2 $(PYTHON) ex2.py -ksp_max_it 5 -on_error_abort && echo "OK" || (echo "FAIL" && exit 1); \
	 else \
		echo 'Python check skipped (PFLARE Python module not built or not found)'; \
	 fi

# Cleanup
clean::
	$(RM) *.so; $(RM) pflare.c; $(RM) pflare_defs.c; $(RM) -r build/; $(RM) -r __pycache__/
